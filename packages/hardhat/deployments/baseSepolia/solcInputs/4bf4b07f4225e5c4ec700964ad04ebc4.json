{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@pythnetwork/entropy-sdk-solidity/EntropyEvents.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./EntropyStructs.sol\";\n\ninterface EntropyEvents {\n    event Registered(EntropyStructs.ProviderInfo provider);\n\n    event Requested(EntropyStructs.Request request);\n    event RequestedWithCallback(\n        address indexed provider,\n        address indexed requestor,\n        uint64 indexed sequenceNumber,\n        bytes32 userRandomNumber,\n        EntropyStructs.Request request\n    );\n\n    event Revealed(\n        EntropyStructs.Request request,\n        bytes32 userRevelation,\n        bytes32 providerRevelation,\n        bytes32 blockHash,\n        bytes32 randomNumber\n    );\n    event RevealedWithCallback(\n        EntropyStructs.Request request,\n        bytes32 userRandomNumber,\n        bytes32 providerRevelation,\n        bytes32 randomNumber\n    );\n\n    event ProviderFeeUpdated(address provider, uint128 oldFee, uint128 newFee);\n\n    event ProviderUriUpdated(address provider, bytes oldUri, bytes newUri);\n\n    event ProviderFeeManagerUpdated(\n        address provider,\n        address oldFeeManager,\n        address newFeeManager\n    );\n\n    event Withdrawal(\n        address provider,\n        address recipient,\n        uint128 withdrawnAmount\n    );\n}\n"
    },
    "@pythnetwork/entropy-sdk-solidity/EntropyStructs.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.0;\n\ncontract EntropyStructs {\n    struct ProviderInfo {\n        uint128 feeInWei;\n        uint128 accruedFeesInWei;\n        // The commitment that the provider posted to the blockchain, and the sequence number\n        // where they committed to this. This value is not advanced after the provider commits,\n        // and instead is stored to help providers track where they are in the hash chain.\n        bytes32 originalCommitment;\n        uint64 originalCommitmentSequenceNumber;\n        // Metadata for the current commitment. Providers may optionally use this field to help\n        // manage rotations (i.e., to pick the sequence number from the correct hash chain).\n        bytes commitmentMetadata;\n        // Optional URI where clients can retrieve revelations for the provider.\n        // Client SDKs can use this field to automatically determine how to retrieve random values for each provider.\n        // TODO: specify the API that must be implemented at this URI\n        bytes uri;\n        // The first sequence number that is *not* included in the current commitment (i.e., an exclusive end index).\n        // The contract maintains the invariant that sequenceNumber <= endSequenceNumber.\n        // If sequenceNumber == endSequenceNumber, the provider must rotate their commitment to add additional random values.\n        uint64 endSequenceNumber;\n        // The sequence number that will be assigned to the next inbound user request.\n        uint64 sequenceNumber;\n        // The current commitment represents an index/value in the provider's hash chain.\n        // These values are used to verify requests for future sequence numbers. Note that\n        // currentCommitmentSequenceNumber < sequenceNumber.\n        //\n        // The currentCommitment advances forward through the provider's hash chain as values\n        // are revealed on-chain.\n        bytes32 currentCommitment;\n        uint64 currentCommitmentSequenceNumber;\n        // An address that is authorized to set / withdraw fees on behalf of this provider.\n        address feeManager;\n    }\n\n    struct Request {\n        // Storage slot 1 //\n        address provider;\n        uint64 sequenceNumber;\n        // The number of hashes required to verify the provider revelation.\n        uint32 numHashes;\n        // Storage slot 2 //\n        // The commitment is keccak256(userCommitment, providerCommitment). Storing the hash instead of both saves 20k gas by\n        // eliminating 1 store.\n        bytes32 commitment;\n        // Storage slot 3 //\n        // The number of the block where this request was created.\n        // Note that we're using a uint64 such that we have an additional space for an address and other fields in\n        // this storage slot. Although block.number returns a uint256, 64 bits should be plenty to index all of the\n        // blocks ever generated.\n        uint64 blockNumber;\n        // The address that requested this random number.\n        address requester;\n        // If true, incorporate the blockhash of blockNumber into the generated random value.\n        bool useBlockhash;\n        // If true, the requester will be called back with the generated random value.\n        bool isRequestWithCallback;\n        // There are 2 remaining bytes of free space in this slot.\n    }\n}\n"
    },
    "@pythnetwork/entropy-sdk-solidity/IEntropy.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.0;\n\nimport \"./EntropyEvents.sol\";\n\ninterface IEntropy is EntropyEvents {\n    // Register msg.sender as a randomness provider. The arguments are the provider's configuration parameters\n    // and initial commitment. Re-registering the same provider rotates the provider's commitment (and updates\n    // the feeInWei).\n    //\n    // chainLength is the number of values in the hash chain *including* the commitment, that is, chainLength >= 1.\n    function register(\n        uint128 feeInWei,\n        bytes32 commitment,\n        bytes calldata commitmentMetadata,\n        uint64 chainLength,\n        bytes calldata uri\n    ) external;\n\n    // Withdraw a portion of the accumulated fees for the provider msg.sender.\n    // Calling this function will transfer `amount` wei to the caller (provided that they have accrued a sufficient\n    // balance of fees in the contract).\n    function withdraw(uint128 amount) external;\n\n    // Withdraw a portion of the accumulated fees for provider. The msg.sender must be the fee manager for this provider.\n    // Calling this function will transfer `amount` wei to the caller (provided that they have accrued a sufficient\n    // balance of fees in the contract).\n    function withdrawAsFeeManager(address provider, uint128 amount) external;\n\n    // As a user, request a random number from `provider`. Prior to calling this method, the user should\n    // generate a random number x and keep it secret. The user should then compute hash(x) and pass that\n    // as the userCommitment argument. (You may call the constructUserCommitment method to compute the hash.)\n    //\n    // This method returns a sequence number. The user should pass this sequence number to\n    // their chosen provider (the exact method for doing so will depend on the provider) to retrieve the provider's\n    // number. The user should then call fulfillRequest to construct the final random number.\n    //\n    // This method will revert unless the caller provides a sufficient fee (at least getFee(provider)) as msg.value.\n    // Note that excess value is *not* refunded to the caller.\n    function request(\n        address provider,\n        bytes32 userCommitment,\n        bool useBlockHash\n    ) external payable returns (uint64 assignedSequenceNumber);\n\n    // Request a random number. The method expects the provider address and a secret random number\n    // in the arguments. It returns a sequence number.\n    //\n    // The address calling this function should be a contract that inherits from the IEntropyConsumer interface.\n    // The `entropyCallback` method on that interface will receive a callback with the generated random number.\n    //\n    // This method will revert unless the caller provides a sufficient fee (at least getFee(provider)) as msg.value.\n    // Note that excess value is *not* refunded to the caller.\n    function requestWithCallback(\n        address provider,\n        bytes32 userRandomNumber\n    ) external payable returns (uint64 assignedSequenceNumber);\n\n    // Fulfill a request for a random number. This method validates the provided userRandomness and provider's proof\n    // against the corresponding commitments in the in-flight request. If both values are validated, this function returns\n    // the corresponding random number.\n    //\n    // Note that this function can only be called once per in-flight request. Calling this function deletes the stored\n    // request information (so that the contract doesn't use a linear amount of storage in the number of requests).\n    // If you need to use the returned random number more than once, you are responsible for storing it.\n    function reveal(\n        address provider,\n        uint64 sequenceNumber,\n        bytes32 userRevelation,\n        bytes32 providerRevelation\n    ) external returns (bytes32 randomNumber);\n\n    // Fulfill a request for a random number. This method validates the provided userRandomness\n    // and provider's revelation against the corresponding commitment in the in-flight request. If both values are validated\n    // and the requestor address is a contract address, this function calls the requester's entropyCallback method with the\n    // sequence number, provider address and the random number as arguments. Else if the requestor is an EOA, it won't call it.\n    //\n    // Note that this function can only be called once per in-flight request. Calling this function deletes the stored\n    // request information (so that the contract doesn't use a linear amount of storage in the number of requests).\n    // If you need to use the returned random number more than once, you are responsible for storing it.\n    //\n    // Anyone can call this method to fulfill a request, but the callback will only be made to the original requester.\n    function revealWithCallback(\n        address provider,\n        uint64 sequenceNumber,\n        bytes32 userRandomNumber,\n        bytes32 providerRevelation\n    ) external;\n\n    function getProviderInfo(\n        address provider\n    ) external view returns (EntropyStructs.ProviderInfo memory info);\n\n    function getDefaultProvider() external view returns (address provider);\n\n    function getRequest(\n        address provider,\n        uint64 sequenceNumber\n    ) external view returns (EntropyStructs.Request memory req);\n\n    function getFee(address provider) external view returns (uint128 feeAmount);\n\n    function getAccruedPythFees()\n        external\n        view\n        returns (uint128 accruedPythFeesInWei);\n\n    function setProviderFee(uint128 newFeeInWei) external;\n\n    function setProviderFeeAsFeeManager(\n        address provider,\n        uint128 newFeeInWei\n    ) external;\n\n    function setProviderUri(bytes calldata newUri) external;\n\n    // Set manager as the fee manager for the provider msg.sender.\n    // After calling this function, manager will be able to set the provider's fees and withdraw them.\n    // Only one address can be the fee manager for a provider at a time -- calling this function again with a new value\n    // will override the previous value. Call this function with the all-zero address to disable the fee manager role.\n    function setFeeManager(address manager) external;\n\n    function constructUserCommitment(\n        bytes32 userRandomness\n    ) external pure returns (bytes32 userCommitment);\n\n    function combineRandomValues(\n        bytes32 userRandomness,\n        bytes32 providerRandomness,\n        bytes32 blockHash\n    ) external pure returns (bytes32 combinedRandomness);\n}\n"
    },
    "@pythnetwork/entropy-sdk-solidity/IEntropyConsumer.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.0;\n\nabstract contract IEntropyConsumer {\n    // This method is called by Entropy to provide the random number to the consumer.\n    // It asserts that the msg.sender is the Entropy contract. It is not meant to be\n    // override by the consumer.\n    function _entropyCallback(\n        uint64 sequence,\n        address provider,\n        bytes32 randomNumber\n    ) external {\n        address entropy = getEntropy();\n        require(entropy != address(0), \"Entropy address not set\");\n        require(msg.sender == entropy, \"Only Entropy can call this function\");\n\n        entropyCallback(sequence, provider, randomNumber);\n    }\n\n    // getEntropy returns Entropy contract address. The method is being used to check that the\n    // callback is indeed from Entropy contract. The consumer is expected to implement this method.\n    // Entropy address can be found here - https://docs.pyth.network/entropy/contract-addresses\n    function getEntropy() internal view virtual returns (address);\n\n    // This method is expected to be implemented by the consumer to handle the random number.\n    // It will be called by _entropyCallback after _entropyCallback ensures that the call is\n    // indeed from Entropy contract.\n    function entropyCallback(\n        uint64 sequence,\n        address provider,\n        bytes32 randomNumber\n    ) internal virtual;\n}\n"
    },
    "contracts/Ludo/Factory.sol": {
      "content": "pragma solidity ^0.8.17;\n\nimport \"./Game.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract LudoFactory is Ownable {\n    struct GameRecord {\n        address gameAddress;\n        address creator;\n        address[] players;\n        address[] podium;\n    }\n\n    GameRecord[] public games;\n    mapping(address => uint256[]) public playerGames;\n\n    event GameCreated(address gameAddress, address creator);\n    event GameFinished(address gameAddress, address[] podium);\n\n    function createGame() external returns (address) {\n        LudoGame newGame = new LudoGame(msg.sender, address(this));\n        games.push(GameRecord({\n            gameAddress: address(newGame),\n            creator: msg.sender,\n            players: new address[](0),\n            podium: new address[](0)\n        }));\n        newGame.initialiseFirstPlayer(msg.sender);\n        uint256 gameId = games.length - 1;\n        playerGames[msg.sender].push(gameId);\n        emit GameCreated(address(newGame), msg.sender);\n        return address(newGame);\n    }\n\n    function recordPlayer(address player) external {\n        require(games.length > 0, \"No games created yet\");\n        uint256 gameId = games.length - 1;\n        require(msg.sender == games[gameId].gameAddress, \"Only the game contract can record players\");\n        games[gameId].players.push(player);\n        playerGames[player].push(gameId);\n    }\n\n    function recordGameResult(address[] memory podium) external {\n        require(games.length > 0, \"No games created yet\");\n        uint256 gameId = games.length - 1;\n        require(msg.sender == games[gameId].gameAddress, \"Only the game contract can record results\");\n        games[gameId].podium = podium;\n        emit GameFinished(games[gameId].gameAddress, podium);\n    }\n\n    function getPlayerGames(address player) external view returns (uint256[] memory) {\n        return playerGames[player];\n    }\n\n    function getGameDetails(uint256 gameId) external view returns (GameRecord memory) {\n        require(gameId < games.length, \"Invalid game ID\");\n        return games[gameId];\n    }\n}\n"
    },
    "contracts/Ludo/Game.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"@pythnetwork/entropy-sdk-solidity/IEntropyConsumer.sol\";\nimport \"@pythnetwork/entropy-sdk-solidity/IEntropy.sol\";\nimport \"./Factory.sol\";\n\ncontract LudoGame is IEntropyConsumer {\n    IEntropy public entropy;\n    address public provider;\n    LudoFactory public factory;\n\n    enum GameState { Waiting, Playing, Finished }\n    \n    struct Player {\n        address addr;\n        uint8[4] pawns;\n        bool[4] inHome;\n        uint8 pawnsAtHome;\n    }\n\n    GameState public state;\n    Player[4] public players;\n    uint8 public currentPlayerTurn;\n    uint8 public playerCount;\n    uint64 public lastSequenceNumber;\n    uint8 public constant BOARD_SIZE = 52;\n    uint8 public constant PAWNS_PER_PLAYER = 4;\n\n    event PlayerJoined(address player);\n    event DiceRolled(address player, uint8 roll);\n    event PawnMoved(address player, uint8 pawnIndex, uint8 newPosition);\n    event PawnKnockedOut(address attacker, address victim, uint8 pawnIndex);\n    event PlayerWon(address player);\n    event GameFinished(address winner);\n\n    modifier onlyFactory() {\n        require(msg.sender == address(factory), \"Only the factory can call this function\");\n        _;\n    }\n\n    constructor(address _creator, address _factory) {\n        factory = LudoFactory(_factory);\n        entropy = IEntropy(0x41c9e39574F40Ad34c79f1C99B66A45eFB830d4c); // Replace with actual Entropy contract address\n        provider = entropy.getDefaultProvider();\n        players[0].addr = _creator;\n        playerCount = 1;\n        state = GameState.Waiting;\n    }\n\n    function initialiseFirstPlayer(address _player) onlyFactory external {\n        players[0].addr = _player;\n        playerCount = 1;\n        state = GameState.Waiting;\n        factory.recordPlayer(_player);\n    }\n\n    function joinGame() external {\n        require(state == GameState.Waiting, \"Game is not in waiting state\");\n        require(playerCount < 4, \"Game is full\");\n        \n        players[playerCount].addr = msg.sender;\n        for (uint8 i = 0; i < PAWNS_PER_PLAYER; i++) {\n            players[playerCount].pawns[i] = 0;\n            players[playerCount].inHome[i] = false;\n        }\n        players[playerCount].pawnsAtHome = PAWNS_PER_PLAYER;\n        playerCount++;\n        \n        factory.recordPlayer(msg.sender);\n\n        if (playerCount == 4) {\n            state = GameState.Playing;\n        }\n        \n        emit PlayerJoined(msg.sender);\n    }\n\n    function rollDice() external {\n        require(state == GameState.Playing, \"Game is not in playing state\");\n        require(msg.sender == players[currentPlayerTurn].addr, \"Not your turn\");\n        uint256 fee = entropy.getFee(provider);\n        uint64 sequenceNumber = entropy.requestWithCallback{value: fee}(provider, keccak256(abi.encodePacked(block.timestamp, msg.sender)));\n        lastSequenceNumber = sequenceNumber;\n    }\n\n    function getEntropy() internal view override returns (address) {\n        return address(entropy);\n    }\n\n    function entropyCallback(uint64 sequenceNumber, address, bytes32 randomNumber) internal override {\n        require(sequenceNumber == lastSequenceNumber, \"Invalid sequence number\");\n        \n        uint8 roll = uint8(uint256(randomNumber) % 6) + 1;\n        emit DiceRolled(players[currentPlayerTurn].addr, roll);\n        \n        bool moved = false;\n        Player storage currentPlayer = players[currentPlayerTurn];\n\n        // Check if player can move any pawn out of home\n        if (roll == 6 && currentPlayer.pawnsAtHome > 0) {\n            for (uint8 i = 0; i < PAWNS_PER_PLAYER; i++) {\n                if (currentPlayer.pawns[i] == 0) {\n                    currentPlayer.pawns[i] = 1;\n                    currentPlayer.pawnsAtHome--;\n                    moved = true;\n                    emit PawnMoved(currentPlayer.addr, i, 1);\n                    break;\n                }\n            }\n        }\n\n        // If no pawn was moved out of home, try to move existing pawns\n        if (!moved) {\n            for (uint8 i = 0; i < PAWNS_PER_PLAYER; i++) {\n                if (currentPlayer.pawns[i] > 0 && !currentPlayer.inHome[i]) {\n                    uint8 newPosition = (currentPlayer.pawns[i] + roll) % BOARD_SIZE;\n                    if (newPosition == 0) newPosition = BOARD_SIZE;\n\n                    // Check if pawn can enter home\n                    if (newPosition > BOARD_SIZE - 6) {\n                        currentPlayer.inHome[i] = true;\n                        currentPlayer.pawnsAtHome++;\n                        emit PawnMoved(currentPlayer.addr, i, newPosition);\n                        moved = true;\n                        break;\n                    }\n\n                    // Check for knocking out other players' pawns\n                    for (uint8 j = 0; j < playerCount; j++) {\n                        if (j != currentPlayerTurn) {\n                            for (uint8 k = 0; k < PAWNS_PER_PLAYER; k++) {\n                                if (players[j].pawns[k] == newPosition) {\n                                    players[j].pawns[k] = 0;\n                                    players[j].pawnsAtHome++;\n                                    emit PawnKnockedOut(currentPlayer.addr, players[j].addr, k);\n                                }\n                            }\n                        }\n                    }\n\n                    currentPlayer.pawns[i] = newPosition;\n                    emit PawnMoved(currentPlayer.addr, i, newPosition);\n                    moved = true;\n                    break;\n                }\n            }\n        }\n\n        // Check if the current player has won\n        if (currentPlayer.pawnsAtHome == PAWNS_PER_PLAYER) {\n            emit PlayerWon(currentPlayer.addr);\n            state = GameState.Finished;\n            emit GameFinished(currentPlayer.addr);\n        } else {\n            // Move to the next player's turn if the current player didn't roll a 6\n            if (roll != 6) {\n                currentPlayerTurn = (currentPlayerTurn + 1) % playerCount;\n            }\n        }\n    }\n\n    function getPawnPositions(uint8 playerIndex) external view returns (uint8[4] memory) {\n        require(playerIndex < playerCount, \"Invalid player index\");\n        return players[playerIndex].pawns;\n    }\n\n    function getPlayerAddress(uint8 playerIndex) external view returns (address) {\n        require(playerIndex < playerCount, \"Invalid player index\");\n        return players[playerIndex].addr;\n    }\n\n    function getCurrentPlayerTurn() external view returns (uint8) {\n        return currentPlayerTurn;\n    }\n\n    function getGameState() external view returns (GameState) {\n        return state;\n    }\n\n    function finishGame() internal {\n        require(state == GameState.Finished, \"Game is not finished\");\n        address[] memory podium = new address[](playerCount);\n        uint8 podiumIndex = 0;\n        for (uint8 i = 0; i < playerCount; i++) {\n            if (players[i].pawnsAtHome == PAWNS_PER_PLAYER) {\n                podium[podiumIndex] = players[i].addr;\n                podiumIndex++;\n            }\n        }\n        factory.recordGameResult(podium);\n    }\n\n    function setEntropyContract(address _entropyAddress) external {\n        require(msg.sender == factory.owner(), \"Only factory owner can set Entropy contract\");\n        entropy = IEntropy(_entropyAddress);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}